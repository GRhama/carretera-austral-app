#!/usr/bin/env node
// scripts/smoke-test.cjs - M√ÅXIMA COBERTURA DE TESTES
const { spawn, exec } = require('child_process');
const fs = require('fs');

console.log('üß™ SMOKE TEST AUTOMATIZADO - M√ÅXIMA COBERTURA\n');

const colors = {
  green: '\x1b[32m',
  red: '\x1b[31m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  cyan: '\x1b[36m',
  reset: '\x1b[0m'
};

function log(message, color = colors.reset) {
  console.log(`${color}${message}${colors.reset}`);
}

function success(message) { log(`‚úÖ ${message}`, colors.green); }
function error(message) { log(`‚ùå ${message}`, colors.red); }
function warning(message) { log(`‚ö†Ô∏è  ${message}`, colors.yellow); }
function info(message) { log(`‚ÑπÔ∏è  ${message}`, colors.blue); }
function highlight(message) { log(`üîç ${message}`, colors.cyan); }

// TESTE 1: Estrutura de arquivos cr√≠ticos
function testFileStructure() {
  info('TESTE 1: Verificando estrutura de arquivos cr√≠ticos...');
  
  const requiredFiles = [
    'src/components/ConsultaMatinal.tsx',
    'src/components/HotelDashboard.tsx',
    'src/hooks/useHoteis.ts',
    'src/hooks/useGastos.ts',
    'src/types/airtable.ts',
    'src/config/airtable.ts',
    'src/utils/postos.test.ts',
    'package.json',
    'vite.config.ts',
    'tailwind.config.js'
  ];

  let passed = true;
  let critical = 0;
  let optional = 0;
  
  requiredFiles.forEach(file => {
    if (fs.existsSync(file)) {
      success(`${file} existe`);
      if (file.includes('ConsultaMatinal') || file.includes('HotelDashboard') || file.includes('useHoteis')) {
        critical++;
      }
    } else {
      if (file.includes('test') || file.includes('config')) {
        warning(`${file} n√£o encontrado (opcional)`);
        optional++;
      } else {
        error(`${file} CR√çTICO n√£o encontrado`);
        passed = false;
      }
    }
  });

  highlight(`Arquivos cr√≠ticos: ${critical}/3 | Opcionais: ${optional}`);
  return passed;
}

// TESTE 2: TypeScript compilation detalhada
function testTypeScript() {
  return new Promise((resolve) => {
    info('TESTE 2: Verifica√ß√£o TypeScript detalhada...');
    
    exec('npx tsc --noEmit --listFiles', (err, stdout, stderr) => {
      if (err) {
        error('Erros de TypeScript detectados:');
        console.log(stderr);
        
        // An√°lise espec√≠fica de erros hotel
        if (stderr.includes('HotelData') || stderr.includes('useHoteis')) {
          error('‚ùå ERRO CR√çTICO: Problemas na integra√ß√£o Hotel');
        }
        if (stderr.includes('ConsultaMatinal')) {
          error('‚ùå ERRO CR√çTICO: Problemas no componente principal');
        }
        
        resolve(false);
      } else {
        success('TypeScript: Compila√ß√£o limpa');
        
        // Contar arquivos processados
        const files = stdout.split('\n').filter(line => line.includes('.tsx') || line.includes('.ts')).length;
        highlight(`Arquivos TypeScript processados: ${files}`);
        
        resolve(true);
      }
    });
  });
}

// TESTE 3: Build detalhado com m√©tricas
function testBuild() {
  return new Promise((resolve) => {
    info('TESTE 3: Build de produ√ß√£o com m√©tricas...');
    
    const startTime = Date.now();
    
    exec('npm run build', (err, stdout, stderr) => {
      const buildTime = ((Date.now() - startTime) / 1000).toFixed(1);
      
      if (err) {
        error(`Build FALHOU em ${buildTime}s:`);
        console.log(stderr);
        resolve(false);
      } else {
        success(`Build SUCESSO em ${buildTime}s`);
        
        // An√°lise do bundle
        try {
          const distPath = 'dist';
          if (fs.existsSync(distPath)) {
            const files = fs.readdirSync(distPath, { recursive: true });
            const jsFiles = files.filter(f => f.includes('.js'));
            const cssFiles = files.filter(f => f.includes('.css'));
            
            highlight(`Bundle: ${jsFiles.length} JS, ${cssFiles.length} CSS files`);
            
            // Verificar tamanho aproximado
            let totalSize = 0;
            files.forEach(file => {
              try {
                const stats = fs.statSync(`${distPath}/${file}`);
                totalSize += stats.size;
              } catch (e) {}
            });
            
            const sizeKB = (totalSize / 1024).toFixed(0);
            if (totalSize > 2 * 1024 * 1024) { // > 2MB
              warning(`Bundle size: ${sizeKB}KB (grande)`);
            } else {
              success(`Bundle size: ${sizeKB}KB`);
            }
          }
        } catch (e) {
          warning('N√£o foi poss√≠vel analisar bundle size');
        }
        
        resolve(true);
      }
    });
  });
}

// TESTE 4: L√≥gica de postos estrat√©gicos (REGRESSION)
function testPostosLogic() {
  info('TESTE 4: Verificando l√≥gica de postos (REGRESSION)...');
  
  const consultaContent = fs.readFileSync('src/components/ConsultaMatinal.tsx', 'utf8');
  let passed = true;
  let features = 0;

  // Verifica√ß√µes cr√≠ticas postos
  const postoChecks = [
    { pattern: 'isUltimo', name: 'L√≥gica destino final' },
    { pattern: 'kmAcumulado.*sort', name: 'Ordena√ß√£o por KM Acumulado' },
    { pattern: 'Descanso em Mendoza|diaAtual === 5', name: 'Caso especial Dia 5' },
    { pattern: 'filterByFormula.*Dia.*=', name: 'Filtro din√¢mico por dia' },
    { pattern: 'postosOrdenados.*map', name: 'Processamento de postos' }
  ];

  postoChecks.forEach(check => {
    const regex = new RegExp(check.pattern, 'i');
    if (regex.test(consultaContent)) {
      success(check.name);
      features++;
    } else {
      error(`${check.name} N√ÉO encontrada`);
      passed = false;
    }
  });

  highlight(`Features de postos: ${features}/${postoChecks.length}`);
  return passed;
}

// TESTE 5: Hotel Integration COMPLETA
function testHotelIntegration() {
  info('TESTE 5: Verificando integra√ß√£o Hotel COMPLETA...');
  
  let passed = true;
  let hotelFeatures = 0;

  // 1. Interface/Tipos
  const typesContent = fs.readFileSync('src/types/airtable.ts', 'utf8');
  const hotelTypeChecks = [
    { pattern: 'interface.*Hotel', name: 'Interface Hotel definida' },
    { pattern: 'Endereco.*string', name: 'Campo Endere√ßo tipado' },
    { pattern: 'Check-in.*string', name: 'Campos de data tipados' }
  ];

  hotelTypeChecks.forEach(check => {
    const regex = new RegExp(check.pattern, 'i');
    if (regex.test(typesContent)) {
      success(check.name);
      hotelFeatures++;
    } else {
      warning(`${check.name} n√£o detectada`);
    }
  });

  // 2. Hook useHoteis
  if (fs.existsSync('src/hooks/useHoteis.ts')) {
    const hookContent = fs.readFileSync('src/hooks/useHoteis.ts', 'utf8');
    const hookChecks = [
      { pattern: 'export.*useHoteis', name: 'Hook useHoteis exportado' },
      { pattern: 'useState.*hotel', name: 'Estado hotel gerenciado' },
      { pattern: 'tables\\.hoteis', name: 'Integra√ß√£o Airtable hot√©is' }
    ];

    hookChecks.forEach(check => {
      const regex = new RegExp(check.pattern, 'i');
      if (regex.test(hookContent)) {
        success(check.name);
        hotelFeatures++;
      } else {
        warning(`${check.name} n√£o detectada`);
      }
    });
  } else {
    error('Hook useHoteis N√ÉO encontrado');
    passed = false;
  }

  // 3. ConsultaMatinal Integration
  const consultaContent = fs.readFileSync('src/components/ConsultaMatinal.tsx', 'utf8');
  const consultaChecks = [
    { pattern: 'useState.*hotel', name: 'Estado hotel na ConsultaMatinal' },
    { pattern: 'HotelData', name: 'Interface HotelData usada' },
    { pattern: 'tables\\.hoteis.*select', name: 'Busca hotel por dia' },
    { pattern: 'hotel\\?', name: 'Renderiza√ß√£o condicional hotel' }
  ];

  consultaChecks.forEach(check => {
    const regex = new RegExp(check.pattern, 'i');
    if (regex.test(consultaContent)) {
      success(check.name);
      hotelFeatures++;
    } else {
      error(`${check.name} N√ÉO encontrada`);
      passed = false;
    }
  });

  highlight(`Features Hotel: ${hotelFeatures}/9`);
  return passed;
}

// TESTE 6: Google Maps & Waze Integration
function testMapsIntegration() {
  info('TESTE 6: Verificando integra√ß√£o Maps & Waze...');
  
  const consultaContent = fs.readFileSync('src/components/ConsultaMatinal.tsx', 'utf8');
  let passed = true;
  let mapsFeatures = 0;

  const mapsChecks = [
    { 
      pattern: 'generateGoogleMapsLink', 
      name: 'Fun√ß√£o Google Maps',
      critical: true
    },
    { 
      pattern: 'generateWazeLink', 
      name: 'Fun√ß√£o Waze',
      critical: true
    },
    { 
      pattern: 'google\\.com/maps/search', 
      name: 'URL Google Maps correta',
      critical: true
    },
    { 
      pattern: 'waze\\.com/ul\\?q=', 
      name: 'URL Waze correta',
      critical: true
    },
    { 
      pattern: 'encodeURIComponent', 
      name: 'Encoding de URLs',
      critical: false
    },
    { 
      pattern: 'window\\.open.*_blank', 
      name: 'Abertura em nova aba',
      critical: false
    }
  ];

  mapsChecks.forEach(check => {
    const regex = new RegExp(check.pattern, 'i');
    if (regex.test(consultaContent)) {
      success(check.name);
      mapsFeatures++;
    } else {
      if (check.critical) {
        error(`${check.name} N√ÉO encontrada`);
        passed = false;
      } else {
        warning(`${check.name} n√£o detectada`);
      }
    }
  });

  highlight(`Features Maps: ${mapsFeatures}/${mapsChecks.length}`);
  return passed;
}

// TESTE 7: HotelDashboard espec√≠fico
function testHotelDashboard() {
  info('TESTE 7: Verificando HotelDashboard...');
  
  let passed = true;
  let dashboardFeatures = 0;

  if (fs.existsSync('src/components/HotelDashboard.tsx')) {
    const hotelContent = fs.readFileSync('src/components/HotelDashboard.tsx', 'utf8');
    
    const dashboardChecks = [
      { pattern: 'AddHotelModal|Modal', name: 'Modal de adicionar hotel' },
      { pattern: 'Endereco|endereco', name: 'Campo endere√ßo no modal' },
      { pattern: 'useHoteis', name: 'Hook useHoteis integrado' },
      { pattern: 'hotel\\.fields\\.Endereco', name: 'Display endere√ßo na lista' },
      { pattern: 'onClick.*Maps|Maps.*onClick', name: 'Bot√µes navega√ß√£o' },
      { pattern: 'hotel.*map', name: 'Lista de hot√©is renderizada' }
    ];

    dashboardChecks.forEach(check => {
      const regex = new RegExp(check.pattern, 'i');
      if (regex.test(hotelContent)) {
        success(check.name);
        dashboardFeatures++;
      } else {
        warning(`${check.name} n√£o detectada`);
      }
    });
  } else {
    error('HotelDashboard.tsx N√ÉO encontrado');
    passed = false;
  }

  highlight(`Features Dashboard: ${dashboardFeatures}/6`);
  return passed;
}

// TESTE 8: Responsividade mobile
function testResponsiveDesign() {
  info('TESTE 8: Verificando design responsivo...');
  
  const consultaContent = fs.readFileSync('src/components/ConsultaMatinal.tsx', 'utf8');
  let responsiveFeatures = 0;

  const responsivePatterns = [
    { pattern: 'grid.*lg:grid-cols', name: 'Grid responsivo' },
    { pattern: 'sm:|md:|lg:|xl:', name: 'Breakpoints Tailwind' },
    { pattern: 'max-w.*mx-auto', name: 'Container responsivo' },
    { pattern: 'px-4.*sm:px', name: 'Padding responsivo' },
    { pattern: 'flex.*space-x|gap', name: 'Layout flex√≠vel' }
  ];

  responsivePatterns.forEach(pattern => {
    const regex = new RegExp(pattern.pattern, 'i');
    if (regex.test(consultaContent)) {
      success(pattern.name);
      responsiveFeatures++;
    } else {
      warning(`${pattern.name} n√£o encontrado`);
    }
  });

  highlight(`Features Responsivas: ${responsiveFeatures}/${responsivePatterns.length}`);
  return responsiveFeatures >= 3; // M√≠nimo 3/5 para passar
}

// TESTE 9: Performance e otimiza√ß√µes
function testPerformance() {
  info('TESTE 9: Verificando otimiza√ß√µes de performance...');
  
  let perfFeatures = 0;
  
  // Verificar lazy loading, memoization, etc.
  const consultaContent = fs.readFileSync('src/components/ConsultaMatinal.tsx', 'utf8');
  
  const perfChecks = [
    { pattern: 'useCallback|useMemo', name: 'Hooks de otimiza√ß√£o' },
    { pattern: 'useState.*loading', name: 'Estados de loading' },
    { pattern: 'catch.*error', name: 'Tratamento de erros' },
    { pattern: 'async.*await', name: 'Opera√ß√µes ass√≠ncronas' }
  ];

  perfChecks.forEach(check => {
    const regex = new RegExp(check.pattern, 'i');
    if (regex.test(consultaContent)) {
      success(check.name);
      perfFeatures++;
    } else {
      warning(`${check.name} n√£o detectada`);
    }
  });

  highlight(`Features Performance: ${perfFeatures}/${perfChecks.length}`);
  return true; // Performance checks s√£o informativos
}

// TESTE 10: Setup de testes
function testTestSetup() {
  info('TESTE 10: Verificando configura√ß√£o de testes...');
  
  let passed = true;
  let testFeatures = 0;

  // Package.json scripts
  const packageJson = JSON.parse(fs.readFileSync('package.json', 'utf8'));
  const requiredScripts = ['test', 'test:smoke', 'test:logic', 'test:integration'];
  
  requiredScripts.forEach(script => {
    if (packageJson.scripts && packageJson.scripts[script]) {
      success(`Script ${script} configurado`);
      testFeatures++;
    } else {
      warning(`Script ${script} n√£o encontrado`);
    }
  });

  // Depend√™ncias de teste
  const testDeps = ['vitest', '@testing-library/react', '@testing-library/jest-dom'];
  testDeps.forEach(dep => {
    if (packageJson.devDependencies && packageJson.devDependencies[dep]) {
      success(`Depend√™ncia ${dep} instalada`);
      testFeatures++;
    } else {
      warning(`Depend√™ncia ${dep} n√£o encontrada`);
    }
  });

  // Arquivos de teste
  const testFiles = ['src/utils/postos.test.ts'];
  testFiles.forEach(file => {
    if (fs.existsSync(file)) {
      success(`Arquivo de teste ${file} existe`);
      testFeatures++;
    } else {
      warning(`Arquivo de teste ${file} n√£o encontrado`);
    }
  });

  highlight(`Setup de testes: ${testFeatures}/8`);
  return testFeatures >= 6; // M√≠nimo 6/8 para passar
}

// TESTE 11: Seguran√ßa e configura√ß√µes
function testSecurity() {
  info('TESTE 11: Verificando seguran√ßa e configura√ß√µes...');
  
  let secFeatures = 0;
  let issues = 0;

  // Verificar se n√£o h√° secrets expostos
  const configContent = fs.readFileSync('src/config/airtable.ts', 'utf8');
  
  if (configContent.includes('process.env') || configContent.includes('import.meta.env')) {
    success('Vari√°veis de ambiente usadas corretamente');
    secFeatures++;
  } else {
    error('Poss√≠veis secrets hardcoded detectados');
    issues++;
  }

  // Verificar .gitignore
  if (fs.existsSync('.gitignore')) {
    const gitignore = fs.readFileSync('.gitignore', 'utf8');
    if (gitignore.includes('.env') && gitignore.includes('dist')) {
      success('.gitignore configurado corretamente');
      secFeatures++;
    } else {
      warning('.gitignore pode estar incompleto');
    }
  }

  // Verificar se n√£o h√° console.logs em produ√ß√£o
  const components = ['src/components/ConsultaMatinal.tsx', 'src/components/HotelDashboard.tsx'];
  let consoleLogs = 0;
  components.forEach(comp => {
    if (fs.existsSync(comp)) {
      const content = fs.readFileSync(comp, 'utf8');
      const logs = (content.match(/console\.log/g) || []).length;
      consoleLogs += logs;
    }
  });

  if (consoleLogs === 0) {
    success('Nenhum console.log em produ√ß√£o');
    secFeatures++;
  } else {
    warning(`${consoleLogs} console.log encontrados`);
  }

  highlight(`Verifica√ß√µes de seguran√ßa: ${secFeatures}/3, Issues: ${issues}`);
  return issues === 0;
}

// TESTE 12: Integra√ß√£o Airtable
function testAirtableIntegration() {
  info('TESTE 12: Verificando integra√ß√£o Airtable completa...');
  
  let passed = true;
  let airtableFeatures = 0;

  const configContent = fs.readFileSync('src/config/airtable.ts', 'utf8');
  
  const airtableChecks = [
    { pattern: 'roteiro.*base', name: 'Tabela roteiro configurada' },
    { pattern: 'gasolina.*base', name: 'Tabela gasolina configurada' },
    { pattern: 'hoteis.*base', name: 'Tabela hot√©is configurada' },
    { pattern: 'export.*tables', name: 'Tables exportadas' }
  ];

  airtableChecks.forEach(check => {
    const regex = new RegExp(check.pattern, 'i');
    if (regex.test(configContent)) {
      success(check.name);
      airtableFeatures++;
    } else {
      error(`${check.name} N√ÉO encontrada`);
      passed = false;
    }
  });

  // Verificar uso correto em components
  const consultaContent = fs.readFileSync('src/components/ConsultaMatinal.tsx', 'utf8');
  const usageChecks = [
    { pattern: 'tables\\.roteiro\\(\\)', name: 'Uso correto tables.roteiro()' },
    { pattern: 'tables\\.gasolina\\(\\)', name: 'Uso correto tables.gasolina()' },
    { pattern: 'tables\\.hoteis\\(\\)', name: 'Uso correto tables.hoteis()' },
    { pattern: 'filterByFormula', name: 'Filtros Airtable implementados' }
  ];

  usageChecks.forEach(check => {
    const regex = new RegExp(check.pattern, 'i');
    if (regex.test(consultaContent)) {
      success(check.name);
      airtableFeatures++;
    } else {
      error(`${check.name} N√ÉO encontrada`);
      passed = false;
    }
  });

  highlight(`Integra√ß√£o Airtable: ${airtableFeatures}/8`);
  return passed;
}

// EXECUTAR TODOS OS TESTES
async function runMaxCoverageTest() {
  console.log(`${colors.blue}üèçÔ∏è INICIANDO SMOKE TEST - M√ÅXIMA COBERTURA${colors.reset}\n`);
  
  const results = [];
  const testNames = [
    'Estrutura de Arquivos',
    'TypeScript Compilation', 
    'Build de Produ√ß√£o',
    'L√≥gica Postos (Regression)',
    'Hotel Integration',
    'Maps & Waze Integration',
    'Hotel Dashboard',
    'Design Responsivo',
    'Performance',
    'Setup de Testes',
    'Seguran√ßa',
    'Integra√ß√£o Airtable'
  ];
  
  // Testes s√≠ncronos
  results.push(testFileStructure());
  results.push(testPostosLogic());
  results.push(testHotelIntegration());
  results.push(testMapsIntegration());
  results.push(testHotelDashboard());
  results.push(testResponsiveDesign());
  results.push(testPerformance());
  results.push(testTestSetup());
  results.push(testSecurity());
  results.push(testAirtableIntegration());
  
  // Testes ass√≠ncronos
  results.push(await testTypeScript());
  results.push(await testBuild());

  // An√°lise de resultados
  const passed = results.filter(r => r === true).length;
  const total = results.length;
  const failed = total - passed;
  const passRate = ((passed / total) * 100).toFixed(1);

  console.log('\n' + '='.repeat(70));
  console.log(`${colors.blue}üìä SMOKE TEST RESULTS - M√ÅXIMA COBERTURA${colors.reset}`);
  console.log('='.repeat(70));
  
  // Resultado detalhado por teste
  results.forEach((result, index) => {
    const status = result ? '‚úÖ' : '‚ùå';
    const color = result ? colors.green : colors.red;
    log(`${status} ${testNames[index]}`, color);
  });

  console.log('\n' + '-'.repeat(70));
  log(`üìà PASS RATE: ${passRate}% (${passed}/${total})`, colors.cyan);
  
  if (failed === 0) {
    success(`üéâ TODOS OS TESTES PASSARAM! (${passed}/${total})`);
    log('\nüöÄ DEPLOY APROVADO! C√≥digo com m√°xima cobertura validada.', colors.green);
    log('\nüìã Pr√≥ximos passos:', colors.blue);
    console.log('  1. npm run test:scenarios (se arquivo existir)');
    console.log('  2. npm run test:integration');
    console.log('  3. npm run deploy');
    process.exit(0);
  } else if (failed <= 2 && passRate >= 80) {
    warning(`‚ö†Ô∏è  TESTES COM WARNINGS (${passRate}% pass rate)`);
    log('\nü§î REVISAR WARNINGS. Deploy poss√≠vel mas recomenda-se corre√ß√µes.', colors.yellow);
    log('\nüìã A√ß√µes recomendadas:', colors.blue);
    console.log('  1. Revisar testes que falharam');
    console.log('  2. Corrigir se cr√≠ticos');
    console.log('  3. Deploy com cautela');
    process.exit(0);
  } else {
    error(`‚ùå MUITOS TESTES FALHARAM (${passRate}% pass rate)`);
    log('\nüö® DEPLOY BLOQUEADO. Corrigir falhas cr√≠ticas antes de continuar.', colors.red);
    log('\nüìã A√ß√µes obrigat√≥rias:', colors.blue);
    console.log('  1. Corrigir todos os erros cr√≠ticos');
    console.log('  2. Re-executar smoke test');
    console.log('  3. Deploy apenas ap√≥s 90%+ pass rate');
    process.exit(1);
  }
}

// Executar
runMaxCoverageTest().catch(err => {
  error('Erro durante smoke test:');
  console.error(err);
  process.exit(1);
});